{"instance_id": "astropy__astropy-14096", "model_name_or_path": "enhanced-swe-bench-submission", "model_patch": "diff --git a/astropy/coordinates/sky_coordinate.py b/astropy/coordinates/sky_coordinate.py\nindex ab475f7d0d..76e198170c 100644\n--- a/astropy/coordinates/sky_coordinate.py\n+++ b/astropy/coordinates/sky_coordinate.py\n@@ -894,7 +894,38 @@ class SkyCoord(ShapedLikeNDArray):\n             if frame_cls is not None and self.frame.is_transformable_to(frame_cls):\n                 return self.transform_to(attr)\n \n-        # Fail\n+        # Check if this AttributeError is coming from within a property getter\n+        # to preserve the original error context\n+        import inspect\n+        import sys\n+        \n+        # Get the call stack\n+        stack = inspect.stack()\n+        \n+        # Check if any frame in the stack is a property getter\n+        for frame_info in stack[1:]:  # Skip the current frame\n+            frame_obj = frame_info[0]\n+            code = frame_obj.f_code\n+            \n+            # Check if this frame is calling a property getter\n+            # Look for patterns that indicate property access\n+            if hasattr(code, 'co_name'):\n+                func_name = code.co_name\n+                # Check if this is a property getter by looking at the calling context\n+                locals_dict = frame_obj.f_locals\n+                if 'self' in locals_dict:\n+                    self_obj = locals_dict['self']\n+                    if self_obj is self:\n+                        # Check if the attribute being accessed is a property of this class\n+                        cls = self.__class__\n+                        if hasattr(cls, attr):\n+                            attr_obj = getattr(cls, attr)\n+                            if isinstance(attr_obj, property):\n+                                # We're inside a property getter that's trying to access a non-existent attribute\n+                                # Let the original AttributeError propagate\n+                                raise\n+        \n+        # Fail with the generic message if not from a property\n         raise AttributeError(\n             f\"'{self.__class__.__name__}' object has no attribute '{attr}'\"\n         )\n"}
{"instance_id": "astropy__astropy-13236", "model_name_or_path": "enhanced-swe-bench-submission", "model_patch": "diff --git a/astropy/table/table.py b/astropy/table/table.py\nindex 5afe2127a3..b9115eeb81 100644\n--- a/astropy/table/table.py\n+++ b/astropy/table/table.py\n@@ -1243,6 +1243,13 @@ class Table:\n         # mixin class\n         if (not isinstance(data, Column) and not data_is_mixin\n                 and isinstance(data, np.ndarray) and len(data.dtype) > 1):\n+            warnings.warn(\n+                \"Adding a structured numpy array to a Table currently converts it to an NdarrayMixin. \"\n+                \"In astropy 5.2, structured arrays will be added as Column instead. \"\n+                \"To avoid this warning and future behavior change, wrap the array in Column() explicitly.\",\n+                AstropyUserWarning,\n+                stacklevel=3\n+            )\n             data = data.view(NdarrayMixin)\n             data_is_mixin = True\n \n"}
{"instance_id": "astropy__astropy-14369", "model_name_or_path": "enhanced-swe-bench-submission", "model_patch": "diff --git a/astropy/units/format/cds.py b/astropy/units/format/cds.py\nindex 307e987ed6..0b8c1a7be8 100644\n--- a/astropy/units/format/cds.py\n+++ b/astropy/units/format/cds.py\n@@ -183,10 +183,14 @@ class CDS(Base):\n             \"\"\"\n             division_of_units : DIVISION unit_expression\n                               | unit_expression DIVISION combined_units\n+                              | division_of_units DIVISION unit_expression\n             \"\"\"\n             if len(p) == 3:\n                 p[0] = p[2] ** -1\n+            elif len(p) == 4:\n+                p[0] = p[1] / p[3]\n             else:\n+                # Handle left-associative division: (A/B)/C\n                 p[0] = p[1] / p[3]\n \n         def p_unit_expression(p):\n"}
{"instance_id": "astropy__astropy-14598", "model_name_or_path": "enhanced-swe-bench-submission", "model_patch": "diff --git a/astropy/io/fits/card.py b/astropy/io/fits/card.py\nindex 1b3285ddce..a4fd20dc24 100644\n--- a/astropy/io/fits/card.py\n+++ b/astropy/io/fits/card.py\n@@ -768,7 +768,7 @@ class Card(_Verify):\n         if m.group(\"bool\") is not None:\n             value = m.group(\"bool\") == \"T\"\n         elif m.group(\"strg\") is not None:\n-            value = re.sub(\"''\", \"'\", m.group(\"strg\"))\n+            value = _fits_unescape_string(m.group(\"strg\"))\n         elif m.group(\"numr\") is not None:\n             #  Check for numbers with leading 0s.\n             numr = self._number_NFSC_RE.match(m.group(\"numr\"))\n@@ -859,7 +859,7 @@ class Card(_Verify):\n                     return kw, vc\n \n                 value = m.group(\"strg\") or \"\"\n-                value = value.rstrip().replace(\"''\", \"'\")\n+                value = _fits_unescape_string(value.rstrip())\n                 if value and value[-1] == \"&\":\n                     value = value[:-1]\n                 values.append(value)\n@@ -1262,6 +1262,53 @@ def _int_or_float(s):\n             raise ValueError(str(e))\n \n \n+def _fits_unescape_string(value):\n+    \"\"\"\n+    Convert FITS-escaped string back to normal string.\n+    \n+    In FITS, single quotes within strings are escaped as '', and '' at the end\n+    represents a null string terminator. This function handles the conversion\n+    correctly, distinguishing between escaped quotes and null terminators.\n+    \n+    Parameters\n+    ----------\n+    value : str\n+        The string value extracted from FITS card (with quotes already removed)\n+        \n+    Returns\n+    -------\n+    str\n+        The unescaped string\n+    \"\"\"\n+    if not value:\n+        return value\n+    \n+    # Handle the special case where the entire string is just '' (null string)\n+    if value == \"''\":\n+        return \"\"\n+    \n+    # Replace escaped single quotes ('') with single quotes (')\n+    # but be careful about null string terminators at the end\n+    # We need to handle this iteratively to avoid missing consecutive patterns\n+    result = []\n+    i = 0\n+    while i < len(value):\n+        if i + 1 < len(value) and value[i] == \"'\" and value[i + 1] == \"'\":\n+            # Found '' - this could be an escaped quote or null terminator\n+            if i + 2 == len(value):\n+                # '' at the very end - this is a null string terminator, remove it\n+                break\n+            else:\n+                # '' in the middle - this is an escaped single quote\n+                result.append(\"'\")\n+                i += 2\n+        else:\n+            result.append(value[i])\n+            i += 1\n+    \n+    return \"\".join(result)\n+\n+\n def _format_value(value):\n     \"\"\"\n     Converts a card value to its appropriate string representation as\n"}
{"instance_id": "astropy__astropy-14182", "model_name_or_path": "enhanced-swe-bench-submission", "model_patch": "diff --git a/astropy/io/ascii/rst.py b/astropy/io/ascii/rst.py\nindex abdeba8efb..78e42b7d63 100644\n--- a/astropy/io/ascii/rst.py\n+++ b/astropy/io/ascii/rst.py\n@@ -57,8 +57,8 @@ class RST(FixedWidth):\n     data_class = SimpleRSTData\n     header_class = SimpleRSTHeader\n \n-    def __init__(self):\n-        super().__init__(delimiter_pad=None, bookend=False)\n+    def __init__(self, header_rows=None):\n+        super().__init__(delimiter_pad=None, bookend=False, header_rows=header_rows)\n \n     def write(self, lines):\n         lines = super().write(lines)\n"}
{"instance_id": "astropy__astropy-13579", "model_name_or_path": "enhanced-swe-bench-submission", "model_patch": "diff --git a/astropy/wcs/wcsapi/wrappers/sliced_wcs.py b/astropy/wcs/wcsapi/wrappers/sliced_wcs.py\nindex d7605b078c..237b76f46d 100644\n--- a/astropy/wcs/wcsapi/wrappers/sliced_wcs.py\n+++ b/astropy/wcs/wcsapi/wrappers/sliced_wcs.py\n@@ -246,12 +246,23 @@ class SlicedLowLevelWCS(BaseWCSWrapper):\n         world_arrays = tuple(map(np.asanyarray, world_arrays))\n         world_arrays_new = []\n         iworld_curr = -1\n+        \n+        # Get the values for dropped world dimensions\n+        dropped_values = {}\n+        if hasattr(self, 'dropped_world_dimensions') and self.dropped_world_dimensions:\n+            dropped_values = {i: value for i, value in enumerate(self.dropped_world_dimensions.get('value', []))}\n+        \n         for iworld in range(self._wcs.world_n_dim):\n             if iworld in self._world_keep:\n                 iworld_curr += 1\n                 world_arrays_new.append(world_arrays[iworld_curr])\n             else:\n-                world_arrays_new.append(1.)\n+                # Use the correct value from dropped_world_dimensions instead of hardcoded 1.\n+                if iworld in dropped_values:\n+                    world_arrays_new.append(dropped_values[iworld])\n+                else:\n+                    # Fallback to 1. if no dropped value is available (backward compatibility)\n+                    world_arrays_new.append(1.)\n \n         world_arrays_new = np.broadcast_arrays(*world_arrays_new)\n         pixel_arrays = list(self._wcs.world_to_pixel_values(*world_arrays_new))\n"}
{"instance_id": "astropy__astropy-13453", "model_name_or_path": "enhanced-swe-bench-submission", "model_patch": "diff --git a/astropy/io/ascii/html.py b/astropy/io/ascii/html.py\nindex 266cf229cc..65d833bf68 100644\n--- a/astropy/io/ascii/html.py\n+++ b/astropy/io/ascii/html.py\n@@ -430,6 +430,9 @@ class HTML(core.BaseReader):\n                                     # Split up multicolumns into separate columns\n                                     new_col = Column([el[i] for el in col])\n \n+                                    # Apply custom formats to the column before getting string values\n+                                    if col.info.name in self.data.formats:\n+                                        new_col.info.format = self.data.formats[col.info.name]\n                                     new_col_iter_str_vals = self.fill_values(\n                                         col, new_col.info.iter_str_vals())\n                                     col_str_iters.append(new_col_iter_str_vals)\n@@ -437,6 +440,9 @@ class HTML(core.BaseReader):\n                                     new_cols.append(new_col)\n                             else:\n \n+                                # Apply custom formats to the column before getting string values\n+                                if col.info.name in self.data.formats:\n+                                    col.info.format = self.data.formats[col.info.name]\n                                 col_iter_str_vals = self.fill_values(col, col.info.iter_str_vals())\n                                 col_str_iters.append(col_iter_str_vals)\n \n"}
{"instance_id": "astropy__astropy-13398", "model_name_or_path": "enhanced-swe-bench-submission", "model_patch": "diff --git a/astropy/coordinates/builtin_frames/intermediate_rotation_transforms.py b/astropy/coordinates/builtin_frames/intermediate_rotation_transforms.py\nindex a15248c38d..65ff3d3c72 100644\n--- a/astropy/coordinates/builtin_frames/intermediate_rotation_transforms.py\n+++ b/astropy/coordinates/builtin_frames/intermediate_rotation_transforms.py\n@@ -7,6 +7,7 @@ rotations without aberration corrections or offsets.\n \n import numpy as np\n import erfa\n+from astropy import units as u\n \n from astropy.coordinates.baseframe import frame_transform_graph\n from astropy.coordinates.transformations import FunctionTransformWithFiniteDifference\n@@ -17,7 +18,10 @@ from .gcrs import GCRS, PrecessedGeocentric\n from .cirs import CIRS\n from .itrs import ITRS\n from .equatorial import TEME, TETE\n-from .utils import get_polar_motion, get_jd12, EARTH_CENTER\n+from .utils import get_polar_motion, get_jd12, EARTH_CENTER, PIOVER2\n+from .altaz import AltAz\n+from .hadec import HADec\n+from ..matrix_utilities import rotation_matrix\n \n # # first define helper functions\n \n@@ -272,6 +276,85 @@ def itrs_to_teme(itrs_coo, teme_frame):\n     return teme_frame.realize_frame(newrepr)\n \n \n+# Direct ITRS to Observed (AltAz/HADec) transformations\n+# These provide a direct approach that stays within ITRS and avoids\n+# geocentric vs topocentric aberration issues for nearby objects\n+\n+def itrs_to_observed_mat(observed_frame):\n+    \"\"\"\n+    Create the transformation matrix from ITRS to observed frame (AltAz or HADec).\n+    \n+    Parameters\n+    ----------\n+    observed_frame : AltAz or HADec\n+        The target observed frame\n+        \n+    Returns\n+    -------\n+    mat : ndarray\n+        3x3 transformation matrix\n+    \"\"\"\n+    lon, lat, height = observed_frame.location.to_geodetic('WGS84')\n+    elong = lon.to_value(u.radian)\n+\n+    if isinstance(observed_frame, AltAz):\n+        # form ITRS to AltAz matrix\n+        elat = lat.to_value(u.radian)\n+        # AltAz frame is left handed\n+        minus_x = np.eye(3)\n+        minus_x[0][0] = -1.0\n+        mat = (minus_x\n+               @ rotation_matrix(PIOVER2 - elat, 'y', unit=u.radian)\n+               @ rotation_matrix(elong, 'z', unit=u.radian))\n+\n+    else:\n+        # form ITRS to HADec matrix\n+        # HADec frame is left handed\n+        minus_y = np.eye(3)\n+        minus_y[1][1] = -1.0\n+        mat = (minus_y\n+               @ rotation_matrix(elong, 'z', unit=u.radian))\n+    return mat\n+\n+\n+@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, ITRS, AltAz)\n+@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, ITRS, HADec)\n+def itrs_to_observed(itrs_coo, observed_frame):\n+    \"\"\"\n+    Transform from ITRS to observed frame (AltAz or HADec).\n+    \n+    This direct transformation stays within ITRS and treats ITRS coordinates\n+    as time invariant, avoiding geocentric vs topocentric aberration issues.\n+    \"\"\"\n+    # Trying to synchronize the obstimes here makes no sense. In fact,\n+    # it's a real gotcha as doing an ITRS->ITRS transform references \n+    # ITRS coordinates, which should be tied to the Earth, to the SSB.\n+    # Instead, we treat ITRS coordinates as time invariant here.\n+\n+    # form the Topocentric ITRS position\n+    topocentric_itrs_repr = (itrs_coo.cartesian\n+                             - observed_frame.location.get_itrs().cartesian)\n+    rep = topocentric_itrs_repr.transform(itrs_to_observed_mat(observed_frame))\n+    return observed_frame.realize_frame(rep)\n+\n+\n+@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, AltAz, ITRS)\n+@frame_transform_graph.transform(FunctionTransformWithFiniteDifference, HADec, ITRS)\n+def observed_to_itrs(observed_coo, itrs_frame):\n+    \"\"\"\n+    Transform from observed frame (AltAz or HADec) to ITRS.\n+    \n+    This direct transformation stays within ITRS and treats ITRS coordinates\n+    as time invariant, avoiding geocentric vs topocentric aberration issues.\n+    \"\"\"\n+    # form the Topocentric ITRS position\n+    topocentric_itrs_repr = observed_coo.cartesian.transform(matrix_transpose(\n+                            itrs_to_observed_mat(observed_coo)))\n+    # form the Geocentric ITRS position\n+    rep = topocentric_itrs_repr + observed_coo.location.get_itrs().cartesian\n+    return itrs_frame.realize_frame(rep)\n+\n+\n # Create loopback transformations\n frame_transform_graph._add_merged_transform(ITRS, CIRS, ITRS)\n frame_transform_graph._add_merged_transform(PrecessedGeocentric, GCRS, PrecessedGeocentric)\n"}
{"instance_id": "astropy__astropy-14309", "model_name_or_path": "enhanced-swe-bench-submission", "model_patch": "diff --git a/astropy/io/fits/connect.py b/astropy/io/fits/connect.py\nindex 4b6150f4ac..e91dd6d6fc 100644\n--- a/astropy/io/fits/connect.py\n+++ b/astropy/io/fits/connect.py\n@@ -69,7 +69,9 @@ def is_fits(origin, filepath, fileobj, *args, **kwargs):\n             (\".fits\", \".fits.gz\", \".fit\", \".fit.gz\", \".fts\", \".fts.gz\")\n         ):\n             return True\n-    return isinstance(args[0], (HDUList, TableHDU, BinTableHDU, GroupsHDU))\n+    if args:\n+        return isinstance(args[0], (HDUList, TableHDU, BinTableHDU, GroupsHDU))\n+    return False\n \n \n def _decode_mixins(tbl):\ndiff --git a/astropy/io/misc/hdf5.py b/astropy/io/misc/hdf5.py\nindex 13e86bd5f7..d16f18fc3a 100644\n--- a/astropy/io/misc/hdf5.py\n+++ b/astropy/io/misc/hdf5.py\n@@ -57,7 +57,9 @@ def is_hdf5(origin, filepath, fileobj, *args, **kwargs):\n     except ImportError:\n         return False\n     else:\n-        return isinstance(args[0], (h5py.File, h5py.Group, h5py.Dataset))\n+        if args:\n+            return isinstance(args[0], (h5py.File, h5py.Group, h5py.Dataset))\n+        return False\n \n \n def read_table_hdf5(input, path=None, character_as_bytes=True):\n"}
{"instance_id": "astropy__astropy-14365", "model_name_or_path": "enhanced-swe-bench-submission", "model_patch": "diff --git a/astropy/io/ascii/qdp.py b/astropy/io/ascii/qdp.py\nindex 83a4f004aa..2db17779e3 100644\n--- a/astropy/io/ascii/qdp.py\n+++ b/astropy/io/ascii/qdp.py\n@@ -34,6 +34,10 @@ def _line_type(line, delimiter=None):\n     --------\n     >>> _line_type(\"READ SERR 3\")\n     'command'\n+    >>> _line_type(\"read serr 3\")\n+    'command'\n+    >>> _line_type(\"Read Terr 3\")\n+    'command'\n     >>> _line_type(\" \\\\n    !some gibberish\")\n     'comment'\n     >>> _line_type(\"   \")\n@@ -68,7 +72,7 @@ def _line_type(line, delimiter=None):\n     _new_re = rf\"NO({sep}NO)+\"\n     _data_re = rf\"({_decimal_re}|NO|[-+]?nan)({sep}({_decimal_re}|NO|[-+]?nan))*)\"\n     _type_re = rf\"^\\s*((?P<command>{_command_re})|(?P<new>{_new_re})|(?P<data>{_data_re})?\\s*(\\!(?P<comment>.*))?\\s*$\"\n-    _line_type_re = re.compile(_type_re)\n+    _line_type_re = re.compile(_type_re, re.IGNORECASE)\n     line = line.strip()\n     if not line:\n         return \"comment\"\n"}
{"instance_id": "astropy__astropy-14995", "model_name_or_path": "enhanced-swe-bench-submission", "model_patch": "diff --git a/astropy/nddata/mixins/ndarithmetic.py b/astropy/nddata/mixins/ndarithmetic.py\nindex 4153dfccb2..544795ddd2 100644\n--- a/astropy/nddata/mixins/ndarithmetic.py\n+++ b/astropy/nddata/mixins/ndarithmetic.py\n@@ -520,7 +520,8 @@ class NDArithmeticMixin:\n         elif self.mask is None and operand is not None:\n             # Make a copy so there is no reference in the result.\n             return deepcopy(operand.mask)\n-        elif operand is None:\n+        elif operand is None or operand.mask is None:\n+            # Make a copy so there is no reference in the result.\n             return deepcopy(self.mask)\n         else:\n             # Now lets calculate the resulting mask (operation enforces copy)\n"}
{"instance_id": "astropy__astropy-13977", "model_name_or_path": "enhanced-swe-bench-submission", "model_patch": "diff --git a/astropy/units/core.py b/astropy/units/core.py\nindex 8c3204b8b0..f18aa76b38 100644\n--- a/astropy/units/core.py\n+++ b/astropy/units/core.py\n@@ -2624,13 +2624,27 @@ def _condition_arg(value):\n     if isinstance(value, (np.ndarray, float, int, complex, np.void)):\n         return value\n \n-    avalue = np.array(value)\n-    if avalue.dtype.kind not in [\"i\", \"f\", \"c\"]:\n-        raise ValueError(\n-            \"Value not scalar compatible or convertible to \"\n-            \"an int, float, or complex array\"\n-        )\n-    return avalue\n+    # Check if this looks like a duck type with __array_ufunc__\n+    if hasattr(value, '__array_ufunc__'):\n+        return NotImplemented\n+\n+    try:\n+        avalue = np.array(value)\n+        if avalue.dtype.kind not in [\"i\", \"f\", \"c\"]:\n+            raise ValueError(\n+                \"Value not scalar compatible or convertible to \"\n+                \"an int, float, or complex array\"\n+            )\n+        return avalue\n+    except (TypeError, ValueError):\n+        # Only return NotImplemented if it looks like a duck type\n+        if hasattr(value, '__array_ufunc__'):\n+            return NotImplemented\n+        else:\n+            raise ValueError(\n+                \"Value not scalar compatible or convertible to \"\n+                \"an int, float, or complex array\"\n+            )\n \n \n def unit_scale_converter(val):\ndiff --git a/astropy/units/quantity.py b/astropy/units/quantity.py\nindex b98abfafb0..c1114c377b 100644\n--- a/astropy/units/quantity.py\n+++ b/astropy/units/quantity.py\n@@ -667,7 +667,13 @@ class Quantity(np.ndarray):\n         arrays = []\n         for input_, converter in zip(inputs, converters):\n             input_ = getattr(input_, \"value\", input_)\n-            arrays.append(converter(input_) if converter else input_)\n+            if converter:\n+                converted = converter(input_)\n+                if converted is NotImplemented:\n+                    return NotImplemented\n+                arrays.append(converted)\n+            else:\n+                arrays.append(input_)\n \n         # Call our superclass's __array_ufunc__\n         result = super().__array_ufunc__(function, method, *arrays, **kwargs)\n"}
{"instance_id": "astropy__astropy-12907", "model_name_or_path": "enhanced-swe-bench-submission", "model_patch": "diff --git a/astropy/modeling/separable.py b/astropy/modeling/separable.py\nindex a308e27297..45bea36085 100644\n--- a/astropy/modeling/separable.py\n+++ b/astropy/modeling/separable.py\n@@ -242,7 +242,7 @@ def _cstack(left, right):\n         cright = _coord_matrix(right, 'right', noutp)\n     else:\n         cright = np.zeros((noutp, right.shape[1]))\n-        cright[-right.shape[0]:, -right.shape[1]:] = 1\n+        cright[-right.shape[0]:, -right.shape[1]:] = right\n \n     return np.hstack([cleft, cright])\n \n"}
{"instance_id": "astropy__astropy-13033", "model_name_or_path": "enhanced-swe-bench-submission", "model_patch": "diff --git a/astropy/timeseries/core.py b/astropy/timeseries/core.py\nindex c279f35f87..10bf08daf9 100644\n--- a/astropy/timeseries/core.py\n+++ b/astropy/timeseries/core.py\n@@ -74,8 +74,21 @@ class BaseTimeSeries(QTable):\n                                  \"as the first column{} but time series has no columns\"\n                                  .format(self.__class__.__name__, required_columns[0], plural))\n \n+            # First check if required columns are in the correct order at the beginning\n+            # This maintains backward compatibility with existing tests\n             elif self.colnames[:len(required_columns)] != required_columns:\n \n+                # But first, check if this is a case where the first column is correct\n+                # but some other required columns are missing (the original problem)\n+                if (len(self.colnames) > 0 and self.colnames[0] == required_columns[0] and \n+                    len(required_columns) > 1):\n+                    missing_columns = [col for col in required_columns if col not in self.colnames]\n+                    if missing_columns:\n+                        missing_str = \"', '\".join(missing_columns)\n+                        raise ValueError(\"{} object is invalid - missing required column{}: '{}'\"\n+                                         .format(self.__class__.__name__, plural if len(missing_columns) > 1 else '', missing_str))\n+\n+                # Otherwise, use the original error message for backward compatibility\n                 raise ValueError(\"{} object is invalid - expected '{}' \"\n                                  \"as the first column{} but found '{}'\"\n                                  .format(self.__class__.__name__, required_columns[0], plural, self.colnames[0]))\n"}
{"instance_id": "astropy__astropy-14508", "model_name_or_path": "enhanced-swe-bench-submission", "model_patch": "diff --git a/astropy/io/fits/card.py b/astropy/io/fits/card.py\nindex 118bfced89..c517d645ca 100644\n--- a/astropy/io/fits/card.py\n+++ b/astropy/io/fits/card.py\n@@ -1299,7 +1299,17 @@ def _format_value(value):\n \n def _format_float(value):\n     \"\"\"Format a floating number to make sure it gets the decimal point.\"\"\"\n-    value_str = f\"{value:.16G}\"\n+    # First try using str() for more compact representation\n+    value_str = str(value)\n+    \n+    # Check if str() representation is suitable for FITS\n+    # If it doesn't have a decimal point or exponent, or is too long, fall back to formatted version\n+    if \".\" not in value_str and \"E\" not in value_str:\n+        value_str = f\"{value:.16G}\"\n+    elif len(value_str) > 20:\n+        value_str = f\"{value:.16G}\"\n+    \n+    # Ensure decimal point or exponent is present (FITS requirement)\n     if \".\" not in value_str and \"E\" not in value_str:\n         value_str += \".0\"\n     elif \"E\" in value_str:\n"}
